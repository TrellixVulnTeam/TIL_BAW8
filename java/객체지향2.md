[TOC]
# 1. 상속

## 1.1 상속의 정의와 장점

" 기존의 클래스의 자산(멤버)를 재사용하여 새로운 클래스를 작성하는 것 "

- 적은 양의 코드로 새로운 클래스 작성 가능
- 코드의 추가 및 변경이 용이하다
- 코드의 재사용성을 높이고 코드 중복을 제거, 프로그램의 생산성과 유지보수에 기여
- 조상클래스 - 자손클래스 관계

```java
public class Person {
  String name;
  
  void eat(){}
  void jump(){}
}

public class SpiderMan extends Person {
  boolean isSpider;
  
  void fireWeb(){}
}
```

```java
public class SpiderManTest {
  public static void main(String[] args) {
    SpiderMan sman = new SpiderMan();
    // 고유기능 활용
    sman.fireWeb();
    // 물려받은 기능 활용
    sman.eat();
  }
}
```



## 1.2 클래스 간의 관계 - 포함관계

- 동일한 이름의 메서드가 두 부모에게 모두 있다면 자식은 어떤 메서드를 쓸 것인가? 
- => 다중 상속의 문제 발생, 포함관계로 단점 극복!

![image-20220111205132605](객체지향2.assets/image-20220111205132605.png)

- 상속 이외의 클래스를 재활용하는 방법!

**" 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것"**

- 코드가 간결해진다.
- 단위클래스별로 코드가 작게 나뉘어있어 관리가 수월하다.
- UML 실선 표시
- Spider 코드 수정시 SpiderMan에도 반영되므로 유지 보수성 확보

```java
public class SpiderMan extends Person { // is a 관계
  // 포함관계 - 스파이더 타입의 스파이더 has a 관계
  
  // Spider spider; 기본값 null로 초기화되어있어 생성자로 생성해야함.
  Spider spider = new Spider();
  
  // 고유 속성, 기능 정의
  boolean isSpider;
  
  void fireWeb() {
    if (isSpider) {
      spider.fireWeb();
    } else {
      System.out.println("Person은 fireWeb 사용 불가")
    }
  }
}
```

```java
public class SpiderManTest {
  public static void main(String[] args) {
    SpiderMan sman = new SpiderMan();
    // 고유기능 활용
    sman.isSpider = true;
    sman.fireWen();
    // 물려받은 기능 활용
    sman.eat();
  }
}
```





## 1.3 클래스간의 관계 결정하기

### 상속관계 `is a`

- "~은 ~이다."

### 포함관계 `has a`

- "~은 ~을 가지고 있다" 



## 1.4 단일 상속(single inheritance)

- Java는 단일상속만을 허용한다. 
- 비중이 높은 클래스 하나만 상속관계로, 나머지는 포함관계로 한다.

### ✅ 생성자!

- **자식클래스의 인스턴스 생성 시 부모 클래스의 생성자가 만드시 불린다!!**





## 1.5 Object 클래스 (superclass)

![image-20220111212137746](객체지향2.assets/image-20220111212137746.png)

- toString()은 객체를 문자열로 변경하는 메서드 - 주소값이 아닌 내용이 필요하기 때문에 => 재정의

```java
@Override
public String toString() {
  return this.속성;
}
```

=> Generate toString으로 자동생성 가능하다.



- 모~든 클래스의 조상 클래스
- 조상이 없는 클래스는 **자동적으로** Object 클래스를 상속받게 된다.
- 상속계층도 최상위에는 Object 클래스가 위치한다.

### Object 메서드

- `.toString()` => 자식클래스에서 오버라이딩해서 사용한다. 

```java
pubic class Person extends Object{
  public final String firstName;
  public final String lastName;
  
  pubic Person(String firstName, String lastNmae) {
    this.firstName = firstName;
    this.lastName = lastName;
  }
  
  @Override
  public String toString() {
    return firstName + " " + lastName;
  }
}
```

```java
public class Main {
  public static void main(String[] args) {
    Person person = new Person("의진","방");
    // Object object = new Object();
    
    System.out.println(person.toString());
    System.out.println(person.toString());
  }
}
```

=> 방의진

=> 방의진 (println 메서드가 toString 메서드를 호출하므로 객체를 넘겨도 된다.)



# 2. method 오버라이딩

## 2.1 오버라이딩(overriding)이란?

" 조상클래스로부터 상속받은 메서드의 내용을 변경하는 것 "



### tip. @override 는 선택



## 2.2 오버라이딩의 조건

자손 클래스에서 오버라이딩하는 메서드는 조상클래스의 메서드와

- **메드의 이름이 같아야 한다.**
- **매개변수의 개수, 타입, 순서가 같아야 한다.**
- **리턴타입이 같아야 한다.**

조상 클래스의 메서드를 자손 클래스에서 오버라이딩 할 때

- 접근 제어자는 부모보다 범위가 넓거나 같아야 한다..
- 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.
- 인스턴스메서드를 static 메서드로, 또는 그 반대로 변경할 수 없다.



## 2.3 오버로딩(over loading) vs. 오버라이딩(overriding)

- 오버로딩(over loading) - 추가적재
  - **같은 이름의 메서드 여러개를 가지면서, 매개변수(파라미터)의 유형와 개수만 다르게 하여 다양한 호출에 다르게 응답한다.**
  - 오버로딩의 조건
    - 1. 메서드 명이 같아야 한다. 2. 파라미터가 달라야 한다.
  
- 오버라이딩(overriding) 

  - **메서드 이름도 같고, 매개변수도 같고, 반환형도 같을때 부모 클래스의 메서드는 무시하고 자식 클래스의 메서드 기능을 사용하겠다.**
  - 상속받은 메서드의 내용을 변경하는 것(change, modify)
  
  

## 2.4 super

### this 통해 member에 접근했듯이 super를 통해 조상 클래스 멤버에 접근

![image-20220111213634763](객체지향2.assets/image-20220111213634763.png)

" 자손클래스에서 조상클래스로부터 상속받은 멤버를 참조하는데 사용하는 참조변수 "

- `super.x` 는 조상 클래스로부터 상속받은 멤버변수 x 를 뜻하며, `this.x` 는 자손 클래스에 선언된 멤버변수를 뜻한다.



## 2.5 super()

- this()가 해당 클래스의 다른 생성자를 호출하는 super() 는 " 조상 클래스의 생성자를 호출한다. "

Object 클래스를 제외한 모든 클래스의 생성자 첫 줄에 생성자.this() 또는 super()를 호출해야 한다. 그렇지 않으면 컴파일러가 자동적으로 `super();` 를 생성자의 첫줄에 삽입한다. 

자손 클래스의 인스턴스를 생성할 때, 조상 클래스의 멤버변수도 조상의 생성자에 의해 초기화되도록 해야 한다.

![image-20220111215105589](객체지향2.assets/image-20220111215105589.png)

## 헷갈리는 super 뿌셔뿌셔!!!

- **호출순서**
  - 1. **생성자 호출 : 조상 -> 부모 -> 자손 순으로 호출**
    2. **메서드 호출 : 오버라이드 한 경우 자식것만 호출**

- 주의할점 1 - 부모클래스에 기본생성자가 없으면 자식클래스에서 명확하게 호출해야한다.
- 주의할점 2 - 부모 클래스의 생성자 호출은 자식 클래스의 맨 첫줄에서 불려야 한다.

```java
public class A {
  	// 생성자
    public A() {
        System.out.println("1");
    }
		// 메서드
    public void a() {
        System.out.println("2");
    }
}

public class B extends A {
    // empty class!
}

public class C extends A {
    public void a() {
        System.out.println("3");
    }
}

public class D extends C {
    public void a() {
        System.out.println("4");
        super.a();
    }
}
```

```java
B b = new B();
b.a();
```

1. 자식클래스인 B의 인스턴스가 생성될 때, 부모 클래스의 생성자가 불리게 된다. 따로 명시하지 않을 경우 부모클래스의 기본생성자(파라미터가 없는 생성자) 가 불리게 되어 먼저 `1` 이 출력된다.
2. 이후 b.a()를 호출하는데, B는 A의 메서드를 상속받기 때문에 A의 a메서드가 호출되어 `2` 가 출력된다. 

```java
C c = new C();
c.a();
```

1. 자식클래스인 C의 인스턴스가 생성될 때, 부모 클래스의 생성자가 불리게 된다. 따로 명시하지 않았으므로 A의 기본생성자가 불려 `1` 이 출력된다.
2. 이후 c.a()를 호출하는데 C는 A의 메서드를 `override` 했기 때문에 A의 a메서드가 아닌 C의 a메서드가 호출되어 `3` 이 출력된다.

```java
D d = new D();
d.a();
```

1. 자식클래스인 D의 인스턴스가 생성될 때, 부모클래스 C의 생성자와 부모의 부모 생성자까지 불린다. 따라서 C의 생성자는 따로 출력값이 없고, A의 생성자로 `1` 이 출력된다.
2. d.a()를 호출하는데, D는 부모클래스 C의 a 메서드를 `override` 했기 때문에 D의 a메서드가 호출된다. 따라서 일단 `4` 가 출력되고 super.a()가 불린다. super.a()는 부모클래스인 C의 a메소드이기 때문에 `3` 이 출력된다.





# 3. package와 import

## 3.1 패키지(package)

- 서로 관련된 클래스와 인터페이스의 묶음
- 클래스가 물리적으로 클래스파일인 것처럼, 패키지는 물리적으로 폴더이다. 패키지는 서브패키지를 가질 수 있으며, '.' 으로 구분한다.
- 클래스의 실제 이름은 패키지명이 포함된 것이다. 
- `rt.jar` 는 Java API의 기본 클래스들을 압축한 파일이다.



## 3.2 패키지의 선언

- 패키지는 소스파일에 첫 번째 문장으로 단 한번 선언한다.
- 하나의 소스파일에 둘 이상의 클래스가 포함된 경우, 모두 같은 패키지에 속하게 된다.
- 하나의 소스파일에는 단 하나의 public 클래스만 허용한다.
- 모든 클래스는 하나의 패키지에 속하며, 패키지가 선언되지 않은 클래스는 자동적으로 이름없는(unnamed) 패키지에 속하게 된다.



### tip. package naming

- 소속.프로젝트.용도

```
com.ssafy.  projectName.  common
```



## 3.3 클래스패스(classpath) 설정





## 3.4 import문

- 다른 패키지에 선언된 클래스를 사용하기 위한 키워드

- 사용할 클래스가 속한 패키지를 지정하는데 사용한다.
- import 문을 사용하면 클래스를 사용할 때 패키지명을 생략할 수 있다.
- `java.lang` 패키지의 클래스는 import 하지 않고도 사용할 수 있다.

- import한 패키지 클래스명이 동일하여 구분해야할 때는 클래스 이름 앞에 전체 패키지명을 입력하자

  ```java
  java.util.List list = new java.util.ArrayList();
  ```

  



## 3.5 import 문의 선언

- import 은 패키지문과 클래스선언의 사이에 선언한다.

```
 순서
1. package문
2. import문
3. 클래스 선언
```

- import 문을 선언하는 방법은 다음과 같다.

```
import 패키지명.클래스명;
import 패키지명.*;
```



# 4. 제어자

## 4.1 제어자(modifier)란?

- 클래스, 변수, 메서드의 선언부에 사용되어 부가적인 의미를 부여한다.
- 제어자는 크게 접근 제어자와 그 외 제어자로 나뉜다.
- 하나의 대상에 여러 개의 제어자를 조합해서 사용할 수 있으나, 접근 제어자는 단 하나만 사용할 수 있다.

```
접근 제어자 - public, protected, default, private
```

```
그 외 - static, final, abstract, native, transient, synchronized, volatile, strictfp
```

- 접근제어자 + 일반제어자 + 타입 + 변수

```java
public class MarketGood {
    // 인스턴스 변수
    // 접근제어자 public, 일반제어자 final 
    // => 바꿀 수 없으므로 private 아니어도 되고 => getter, setter도 사용하지 않아도 된다.
    public final String name;
    public final int retailPrice;
    private int discountRate;
  ...
}
```



## 4.2 static  - 클래스의 , 공통적인

- 변수 앞에 붙여 해당 클래스의 모든 instance들이 사용할 수 있어진다.

![image-20211230201750494](객체지향2.assets/image-20211230201750494.png)



## 4.3 final - 마지막의 , 변경될 수 없는

![image-20211230142525764](객체지향2.assets/image-20211230142525764.png)

- `static` 과 함께 사용하여 상수를 만든다.
- 상수는 인스턴스에 해당되는 것이 아니므로 클래스 공통 성질을 주기 위해서이다.

```java
public calss Constants {
  public static final double PI = 3.14;
  public static final String THIS_IS_HOW_TO_NAME_CONSTANT_VARIABLE = "Hello";
  ...
}
```





## 4.4 생성자를 이용한 final 멤버 변수 초기화

## 4.5 abstract

## 4.6 접근 제어자(access modifier)

멤버 또는 클래스에 사용되어 외부로부터의 접근을 제한한다.

### public

- 파일 내에 public 클래스는 하나만 있어야 하기 때문에, 파일을 대표하는 클래스에 `public` 을 붙인다.
- 또한 자바에서는 파일명과 클래스명이 같아야 한다.

![image-20211229114544507](객체지향2.assets/image-20211229114544507.png)



### protected

- 같은 패키지 내에서, 다른 패키지의 자손클래스에서 접근이 가능하다.
- 부모 클래스의 balance 변수에 바로 접근이 가능하다.

```java
public class BankAccount {
    protected int balance;
    ...
}

public class MinimumBalanceAccount extends BankAccount {
    ...
    @Override
    public boolean withdraw(int amount) {
        // if (getBalance() - amount < minimum) {
        if (balance - amount < minimum) {
            System.out.println("적어도 " + minimum + "원은 남겨야 합니다.");
            return false;
        }
    
        // setBalance(getBalance() - amount);
        balance -= amount;
        return true;
    }
}
```



## 4.7 접근 제어자를 이용한 캡슐화

- 접근 제어자를 사용하는 이유
  - 외부로부터 데이터 보호
  - 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서

```java
class Time {
  // private 접근제어자 사용. Time class 내에서만 사용가능하다.
  private int hour;
  private int minute;
  private int second;
  
  // 매개변수가 있는 생성자
  Time(int hour, int minute, int second) {
    setHour(hour);
    setMinute(minute);
    setSecond(second);
  }
  
  // 외부에서 접근 가능한 public 메서드를 통해 setter, getter로 활용가능하게 만든다.
  public int getHour() {
    return hour;
  }
  
  public void setHour() {
    if (hour < 0 || hour > 23) return;
    this.hour = hour;
  }
  
  // ...
  
  // System.out.println(t); 하면 아래 리턴값이 출력됨 => 어떻게..?
  public String toString() {
    return hour + ":" + minute + ":" + second;
  }
}
```

```java
public static void main(String[] args) {
  // 매개변수가 있는 생성자
  Time t = new Time(12, 35, 30);
  System.out.println(t);
  
  t. setHour(t.getHour()+1);
  System.out.println(t);
}
```



## 4.8 생성자의 접근 제어자

## 4.9 제어자의 조합



# 5. 다형성

## 5.1 다형성(polymorphism) 이란?

- 여러 가지 형태를 가질 수 있는 능력
- 하나의 참조변수로 여러 타입의 객체를 참조할 수 있는 것
- 즉, 조상타입의 참조변수로 자손타입의 객체를 다룰 수 있는 것.
- "조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있지만, 반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다."

```java
class TV {
  boolean power;
  int channel;
  
  void power() { power = @ !power; }
  void channelUp() { ++channel; }
  void channelDown() { --channel; }
}

class CaptionTv extends Tv {
  String text;
  void caption() {}
}
```

```java
// 부모의 참조변수로 자손 타입의 인스턴스를 생성

TV t = new CaptionTv();
CaptionTv c = new CaptionTv();
```



## 5.2 참조변수의 형변환

- 서로 상속관계에 있는 타입간의 형변환만 가능하다.
- 자손타입에서 조상타입으로 형변환하는 경우, 형 변환 생략이 가능하다.



## 5.3 instanceof 연산자

- 참조변수가 참조하는 인스턴스의 실제 타입을 체크하는데 사용한다.
- 이상연산자이며 피연산자는 참조형 변수와 타입이다.
- 연산결과는 true, falsed이다.
- isinstanceof의 연산결과가 true이면, 해당 타입으로 형변환이 가능하다.



## 5.4 참조변수와 인스턴스변수의 연결

## 5.5 매개변수의 다형성

## 5.6 여러 종류의 객체를 하나의 배열로 다루기

- 조상타입의 배열에 자손들의 객체를 담을 수 있다.

```java 
Product p[] = new product[3];
p[0] = new Tv();
p[1] = new Computer();
p[2] = new Audio();
```



# 6. 추상클래스

## 6.1 추상클래스(abstract class) 란?

미완성 메서드를 포함하고 있는 클래스

- 추상클래스로 인스턴스를 생성할 수 없다.
- 추상클래스는 상속을 통해 자손클래스에 의해서만 완성된다.



## 6.2 추상메서드(abstract method) 란?

선언부만 작성하고 구현부는 작성하지 않은 채 남겨둔 메서드

```java
abstract 리턴타입 메서드명();
```

추상클래스로부터 상속받는 자손클래스는 오버라이딩을 통해 조상인 추상클래스와 메서드를 모두 구현해야 한다. 만일 조상으로부터 상속받은 추상메서드 중 하나라도 구현하지 않는다면, 자손클래스 역시 추상클래스로 지정해 주어야 한다.

```java
abstract class Player {
  abstract void play(int pos);
  abstract void stop();
}

class AudioPlayer extends Player {
  void play(int pos) { ... } // 추상메서드 구현
  void stop() { ... }
}

abstract class AbstractPlayer extends Player {
  void play(int pos) { ... }
}
```

## 6.3 추상클래스의 작성

- 유닛 세 개는 공통적으로 stop 기능을 가지고 있다.
- 또한 move도 가지고 있는데, 구현 방법은 다르지만 선언은 같으므로 추상메서드로 만들 수 있다.

```java
abstract class Unit {
  int x, y;
  abstract void move(int x, int y);
  void stop() { /*현재 위치에 정지 */ }
}

class Marine extends Unit {
  void move(int x, int y) {}
  void stimPack()
}

class Tank extends Unit {
  void move(int x, int y) {}
  void load() {}
  void unload() {}
}
```

- 이 코드를 공통조상인 Unit 클래스 타입의 참조변수 배열에 담을 수 있다.
- 조상 클래스타입의 참조변수로 자손 클래스의 인스턴스를 참조할 수 있기 때문에 , 조상 클래스타입의 배열에 자손 클래스의 인스턴스를 담을 수 있다.

```java
Unit[] group = new Unit[4];
group[0] = new Marine;
group[1] = new Tank;
group[2] = new Marine;

// Unit 배열의 모든 유닛을 좌표(100, 200) 위치로 이동한다.
for (int i=0; i < group.length; i++) {
  group[i].move(100, 200);
}
```





# 7. 인터페이스

## 7.1 인터페이스(interface)란?

일종의 추상클래스로, 추상메서드를 갖지만 더 추상화정도가 높아서 추상메서드와 상수만들 변수로 가질 수 있다.

일반 메서드나 멤버 변수도 가질 수 없다.

인터페이스는 기본 설계도로, 다른 클래스를 작성하는 데 도움을 줄 목적으로 작성된다.



## 7.2 인터페이스의 작성

키워드로 클래스대신 인터페이스를 사용한다.

접근제어자 사용이 가능하다.

```java
interface 인터페이스명 {
  public static final 타입 상수명 = 값;
  public abstract 메서드명(매개변수목록);
}
```

- 인터페이스 멤버의 제약

  - 모든 멤버변수는 `public static final` 이어야 하며, 이를 생략할 수 있다.
  - 모든 메서드는 `public abstract` 이어야 하며, 이를 생략할 수 있다.

  

## 7.3 인터페이스의 상속

인터페이스는 인터페이스로부터만 상속받을 수 있으며, 다중상속이 가능하다.

```java
interface Movable {
  void move(int x, int y);
}

interface Attackable {
  void attack(Unit u);
}

interface Fightable extends Movable, Attackable {}
```



## 7.4 인터페이스의 구현

자체 인스턴스 생성은 불가능하며, 자신에게 정의된 추상메서드의 몸통을 만들어주는 클래스를 정의해야 한다.

```java
class Fighter implements Fightable {
  public void move(int x, int y) {}
  public void attack(Unit u) {}
}
```



## 7.5 인터페이스를 이용한 다중상속 

## 7.6 인터페이스의 장점

## 7.7 인터페이스의 이해

- 클래스를 사용하는 쪽(User) 과 클래스를 제공하는 쪽(Provider) 이 있다.
- 메서드를 사용하는 쪽에서는 사용하려는 메서드의 선언부만 알면 된다.

```java
// 클래스 B대신 인터페이스 I를 사용하여 작성
class A {
  public void methodA(I i) {
    i.methodB();
  }
}

// 인터페이스 정의
interface I {
  public abstract void methodB();
}
// 클래스 B가 인터페이스 I를 구현
class B implements I {
  public void methodB() {
    System.out.println("methodB()");
  }
}

class InterfaceTest {
  public static void main(String args[]) {
    A.a = new A();
    a.methodA(new B());
  }
}
```

- 클래스 B가 변경되어도 클래스 A가 영향을 받지 않도록 한다.
