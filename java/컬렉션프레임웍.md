# Collection Framework

[TOC]

# 1.1 컬렉션 프레임웍이란?

# 1.2 컬렉션 프레임웍의 핵심 인터페이스

# 1.3 컬렉션 프레임웍의 동기화

# 1.4 Vector와 ArrayList

# 1.5 ArrayList

# 1.6 Vector 의 크기와 용량

# 1.7 Vector에 저장된 객체의 삭제과정

# 1.8 ArrayList의 단점 - 배열의 단점

# 1.9 Deep copy vs. Shallow copy

# 1.10 LinkedList - 배열의 단점을 보완

# 1.11 LinkedList - 이중 원형 링크드 리스트

# 1.12 ArrayList vs. LinkedList

# 1.13 스택과 큐

# 1.14 Enumeration, Iterator, ListIterator

# 1.15 Iterator

# 1.16 ListIterator

# 1.17 HashSet

# 1.18 TreeSet

# 1.19 Comparator와 Comparable

# 1.20 HashTable과 HashMap

### HashTable

- 데이터 변경 메소드가 모두 동기화 메소드로 선언되어 있다.
- 메소드 호출 전에 `멀티 쓰레드` 환경에서 쓰레드 간에 `동기화 락(Synchronized Lock)` 을 걸기 때문에 데이터의 무결성을 보장한다.
- 동기화 락은 시간이 오래 걸리기 때문에 해시테이블은 속도가 느리다.
- 멀티쓰레드 환경에서 사용하기 적합하다.



### HashMap

- HashMap은 Hashtable의 신버젼으로 동기화 처리가 되어있지 않다. ->?
- HashMap은 해싱 기법을 사용해서 데이터를 저장하기 때문에 많은 양의 데이터를 검색할 때 성능이 뛰어나다.
- HashMap은 Map 인터페이스를 구현하였으며, 데이터를 키와 값의 쌍으로 저장한다.
  - `key` - 컬렉션 내의 키 중에서 유일해야 한다.
  - `value` - 키와 달리 데이터의 중복을 허용한다.

```java
HashMap myMap = new HashMap();
map.put()
```



# 1.21 HashMap



# 1.22 해싱(hashing)

# 1.23 TreeMap

# 1.24 Properties

# 1.25 컬렉션 클래스 정리 & 요약

