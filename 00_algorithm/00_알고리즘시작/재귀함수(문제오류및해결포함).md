# 재귀함수

재귀 함수에는 recursive case와 base case가 있다.

- Recursive case: 현 문제가 너무 커서, 같은 형태의 더 작은 부분 문제를 재귀적으로 푸는 경우
- Base case: 이미 문제가 충분히 작아서, 더 작은 부분 문제로 나누지 않고도 바로 답을 알 수 있는 경우

![image-20211002182158380](재귀함수.assets/image-20211002182158380.png)



## 절차지향적 사고가 아닌 귀납적 사고

- 자연수 n 에 대한 명제 p(n) 이 모든 자연수 n에 대하여 성립함을 증명하려면 다음 두 가지를 보이면 된다.

```python
# 1. n = 1 일때 명제 p(n) 이 성립한다.
# 2. n = k 일때 명제 p(n) 이 성립한다고 가정하면 n = k + 1 일때 명제 p(n) 이 성립한다.
```



## 개요

```python
def countdown(n):
    if n > 0 :
        print(n)
        countdown(n-1)
#countdown(4)를 출력하면
#4
#3
#2
#1
```

```python
def countup(n):
    if n > 0 :
        countup(n-1)
        print(n)
#countup(4)를 출력하면
#1
#2
#3
#4 
```





## 1. 피보나치

### 구현

```python
# n번째 피보나치 수를 리턴
def fib(n):
  	# base case
    if n <= 2:
        return 1
    # recursive case
    else:
        return fib(n-2) + fib(n-1)

# 테스트: fib(1)부터 fib(10)까지 출력
for i in range(1, 11):
    print(fib(i))
```

### 시간복잡도  : ` O(2^n)`

인풋 `n`이 `3`보다 작아지는 base case까지 반복적으로 두 개의 새로운 재귀 호출이 발생





## 2. 숫자합

### 구현

```python
# 1부터 n까지의 합을 리턴
def triangle_number(n):
    # base case
    if n == 1:
        return 1
    # recursive case
    else:
        return n + triangle_number(n-1)

# 테스트: triangle_number(1)부터 triangle_number(10)까지 출력
for i in range(1, 11):
    print(triangle_number(i))
```

### 시간 복잡도 : `O(n)`

Base case의 시간 복잡도는 인풋 크기와 연관이 없으니까 *O*(1)이다.

Recursive case에서는 `triangle_number(n - 1)`의 재귀적 호출을 제외하면 *O*(1)이다.

그런데 재귀문을 통해서 `triangle_number` 함수는 총 *n*번 호출되니까, 총 *O*(*n*)의 시간이 걸리게 된다.





## 3. 자릿수 합

### 구현

```python
# n의 각 자릿수의 합을 리턴
def sum_digits(n):
  	# base case
    if n < 10:
        return n 
    # recursive case
    else:
        return sum_digits(n // 10) + (n % 10)

# 테스트
print(sum_digits(22541))
print(sum_digits(92130))
print(sum_digits(12634))
print(sum_digits(704))
print(sum_digits(3755))
```

### 시간 복잡도 : O(log10n)

인풋 *n*의 자릿수 개수를 *d*

base case 부분은 *O*(1),  `n % 10`도 *O*(1)

`sum_digits`가 재귀적으로 호출될 때마다 *n*은 약1/10로 줄어들기 때문에 매번 한 자리씩 줄어든다고 볼 수 있다.

따라서 `sum_digits`는 약 *d*번 호출된다.

`sum_digits`의 시간 복잡도는*O*(*d*)이다.

혹은 각 자릿수가 log10n + 1이라고 표기할 수 있고 그 때의 시간복잡도는 O(log10n) 이다.





## 4. 리스트 뒤집기

### 구현(오류)

```
TypeError: unsupported operand type(s) for +: 'int' and 'list'
```

### 원인분석

리스트의 마지막 원소를 맨 앞에 놓고, 나머지 원소를 다시 뒤집는 방식으로 문제 접근은 알맞게 하였으나 리턴으로 재귀함수를 호출할 때 리스트 슬라이싱을 올바르게 사용하지 못하였다. 리스트 슬라이싱에 대한 개념이해가 부족하였다.

- list[-1] 의 경우 리스트의 마지막 인덱스값을 출력하기 때문에 Int 가 출력된다.
- list[-1:] 의 경우 리스트의 마지막 인덱스"까지" 슬라이싱 하는 것이므로 [9] 가 출력된다. 

### 해결방안

list[-1] 을 list[-1:] 로 수정하였다.

```python
# 혼동 주의!!
some_list[-1]   # 9
some_list[-1:]  # [9]
```

```python
# 파라미터 some_list를 거꾸로 뒤집는 함수
def flip(some_list):
    # base case
    if len(some_list) == 0 or len(some_list) == 1:
        return some_list
    # recursive case
    else:
        return some_list[-1:] + flip(some_list[:-1])

# 테스트
some_list = [1, 2, 3, 4, 5, 6, 7, 8, 9]
some_list = flip(some_list)
print(some_list)
```

### 리스트 슬라이싱

```python
some_list = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(some_list[-1])  # 9
print(some_list[:-1]) # [1, 2, 3, 4, 5, 6, 7, 8]
print(some_list[-1:]) # [9]
```

### 시간복잡도 : O(n^2) 

base case 는 O(1) 이고 some_list[1:] 과 some_list[:1]은 각각 시간복잡도가 O(1), O(n-1) 이다.

즉, 재귀적 부분을 제외한 시간 복잡도는 O(n)이다.

flip 함수는 매 호출마다 리스트의 길이가 1씩 줄기 때문에 총 n 번 실행된다.

재귀적으로 n번 실행되고 각 호출은 O(n) 이므로 총 시간 복잡도는 O(n^2) 이다.





## 5. 이분탐색 재귀함수로 풀기

### 구현(오류)

첫 시도 : 실패  // tc 2번과 3번만 통과

오류케이스

```
print(binary_search(2, [2, 3, 5, 7, 11])) 
print(binary_search(3, [2, 3, 5, 7, 11])) 
print(binary_search(11, [2, 3, 5, 7, 11]))
```

```python

def binary_search(element, some_list, start_index=0, end_index=None):
    # end_index가 따로 주어지지 않은 경우에는 리스트의 마지막 인덱스
    if end_index == None:
        end_index = len(some_list) - 1
    
    mid_index = (start_index + end_index) // 2
    if start_index <= end_index:
        if some_list[mid_index] == element:
            return mid_index
    elif start_index > end_index:
        return None
    else:
        if some_list[mid_index] > element:
            return binary_search(element, some_list, end_index=mid_index-1)
        else:
            return binary_search(element, some_list, start_index=mid_index+1)
```

2번째 시도 : 실패 // 무한재귀에 빠짐

오류케이스 

```
print(binary_search(3, [2, 3, 5, 7, 11]))
```

```python

def binary_search(element, some_list, start_index=0, end_index=None):
    # end_index가 따로 주어지지 않은 경우에는 리스트의 마지막 인덱스
    if end_index == None:
        end_index = len(some_list) - 1
    
    mid_index = (start_index + end_index) // 2
    if some_list[mid_index] == element:
        return mid_index
    elif start_index > end_index:
        return None
    else:
        if some_list[mid_index] > element:
            return binary_search(element, some_list, start_index=0, end_index=mid_index-1)
        else:
            return binary_search(element, some_list, start_index=mid_index+1, end_index=None)

```

### 원인분석

재귀함수 인자를 넣을때, 4개의 파라미터를 모두 알맞게 설정해주어야 했다. start index와 end index는 모두 계속해서 가변적인데 그것을 고려하지 못했다. 다시 들어갈때 start 인덱스는 항상 0이고 end index는 항상 리스트의 마지막 인덱스일것이라고 착각하였다.

### 해결

재귀함수를 호출할때 앞 함수의 인자를 넣어서 수정하였다. 

```python

def binary_search(element, some_list, start_index=0, end_index=None):
    # end_index가 따로 주어지지 않은 경우에는 리스트의 마지막 인덱스
    if end_index == None:
        end_index = len(some_list) - 1
    
    mid_index = (start_index + end_index) // 2
    if some_list[mid_index] == element:
        return mid_index
    elif start_index > end_index:
        return None
    else:
        if some_list[mid_index] > element:
            return binary_search(element, some_list, start_index=start_index, end_index=mid_index-1)
        else:
            return binary_search(element, some_list, start_index=mid_index+1, end_index=end_index)

print(binary_search(2, [2, 3, 5, 7, 11]))
print(binary_search(0, [2, 3, 5, 7, 11]))
print(binary_search(5, [2, 3, 5, 7, 11]))
print(binary_search(3, [2, 3, 5, 7, 11]))
print(binary_search(11, [2, 3, 5, 7, 11]))

```

### 주석추가 최종수정본

```python

def binary_search(element, some_list, start_index=0, end_index=None):
    # end_index가 따로 주어지지 않은 경우에는 리스트의 마지막 인덱스
    if end_index == None:
        end_index = len(some_list) - 1
        
    # base case: start_index가 end_index보다 크면 some_list안에 element는 없다
    elif start_index > end_index:
        return None
        
    # 범위의 중간 인덱스를 찾는다
    mid_index = (start_index + end_index) // 2
    
    # base case: 이 인덱스의 값이 찾는 값인지 확인을 해준다
    if some_list[mid_index] == element:
        return mid_index
      
    # recursive case
    else:
        if some_list[mid_index] > element:
            return binary_search(element, some_list, start_index=start_index, end_index=mid_index-1)
        else:
            return binary_search(element, some_list, start_index=mid_index+1, end_index=end_index)
          
```



## 6. 하노이의 탑(미완)

### 구현(오류)

이해가 어렵다.

```python
# 가장 작은 원판의 번호 1번
# 가장 큰 원판의 번호는 num_disks
# 왼쪽 기둥이 1번, 가운데 기둥이 2번, 오른쪽 기둥이 3번

def move_disk(disk_num, start_peg, end_peg):
    print("%d번 원판을 %d번 기둥에서 %d번 기둥으로 이동" % (disk_num, start_peg, end_peg))

def hanoi(num_disks, start_peg, end_peg):
    # base_case
    if num_disks == 0:
        return
    # recursive_case
    elif num_disks == 1:
        return move_disk(num_disks, start_peg, end_peg)
    else:
        other_peg = 6 - start_peg - end_peg
        # 가장 큰 원판을 제외하고 나머지 원판들을 start_peg에서 other_peg로 이동
        move_disk(num_disks, start_peg, other_peg로)
        # 가장 큰 원판을 start_peg에서 end_peg로 이동
        move_disk(num_disks, start_peg, end_peg)
        # 나머지 원판들을 other_peg에서 end_peg로 이동
        move_disk(num_disks, other_peg, end_peg)
        return 


# 테스트 코드 (포함하여 제출해주세요)
hanoi(3, 1, 3)
```

```python
# 올바른 출력
hanoi(1, 1, 3)
1번 원판을 1번 기둥에서 3번 기둥으로 이동

hanoi(2, 1, 3)
1번 원판을 1번 기둥에서 2번 기둥으로 이동
2번 원판을 1번 기둥에서 3번 기둥으로 이동
1번 원판을 2번 기둥에서 3번 기둥으로 이동

hanoi(3, 1, 3)
1번 원판을 1번 기둥에서 3번 기둥으로 이동
2번 원판을 1번 기둥에서 2번 기둥으로 이동
1번 원판을 3번 기둥에서 2번 기둥으로 이동
3번 원판을 1번 기둥에서 3번 기둥으로 이동
1번 원판을 2번 기둥에서 1번 기둥으로 이동
2번 원판을 2번 기둥에서 3번 기둥으로 이동
1번 원판을 1번 기둥에서 3번 기둥으로 이동
```

### 해답

```python
def move_disk(disk_num, start_peg, end_peg):
    print("%d번 원판을 %d번 기둥에서 %d번 기둥으로 이동" % (disk_num, start_peg, end_peg))

def hanoi(num_disks, start_peg, end_peg):
    # base case: 옮길 원판이 없으면 부분 문제를 나누지 않고 함수를 끝낸다
    if num_disks == 0:
        return
    else:
        other_peg = 6 - start_peg - end_peg
        
        # 1. 가장 큰 원판을 제외하고 나머지 원판들을 start_peg에서 other_peg로 이동
        hanoi(num_disks - 1, start_peg, other_peg)
        
        # 2. 가장 큰 원판을 start_peg에서 end_peg로 이동
        move_disk(num_disks, start_peg, end_peg)
        
        # 3. 나머지 원판들을 other_peg에서 end_peg로 이동
        hanoi(num_disks - 1, other_peg, end_peg)
```

### 시간 복잡도

우선 재귀적인 부분을 제외하면 `hanoi` 함수의 시간 복잡도는 O(1)*O*(1)입니다.

그렇다면 `hanoi` 함수가 얼만큼 호출되는지만 알면 될 텐데요. Recursive case를 살펴봅시다. `num_disks`를 *n*이라고 했을 때, *n*−1 크기의 부분 문제 2개를 만들어주고 있죠?

`hanoi` 함수는 `num_pegs`가 0이 될 때까지 계속해서 재귀적으로 더 작은 `hanoi` 호출을 하고, 계속해서 부분 문제를 2개씩 만들어 냅니다. `hanoi` 함수를 호출하게 되면, *n*번 만큼 부분 문제가 2배로 늘어나게 되는 거죠. 그렇기 때문에 총 시간 복잡도는 O(2^n) 이 됩니다.
