# 재귀함수

재귀 함수에는 recursive case와 base case가 있다.

- Recursive case: 현 문제가 너무 커서, 같은 형태의 더 작은 부분 문제를 재귀적으로 푸는 경우
- Base case: 이미 문제가 충분히 작아서, 더 작은 부분 문제로 나누지 않고도 바로 답을 알 수 있는 경우

![image-20211002182158380](재귀함수.assets/image-20211002182158380.png)



## 절차지향적 사고가 아닌 귀납적 사고

- 자연수 n 에 대한 명제 p(n) 이 모든 자연수 n에 대하여 성립함을 증명하려면 다음 두 가지를 보이면 된다.

```python
# 1. n = 1 일때 명제 p(n) 이 성립한다.
# 2. n = k 일때 명제 p(n) 이 성립한다고 가정하면 n = k + 1 일때 명제 p(n) 이 성립한다.
```



## 개요

```python
def countdown(n):
    if n > 0 :
        print(n)
        countdown(n-1)
#countdown(4)를 출력하면
#4
#3
#2
#1
```

```python
def countup(n):
    if n > 0 :
        countup(n-1)
        print(n)
#countup(4)를 출력하면
#1
#2
#3
#4 
```



## 1. 피보나치

### 구현

```python
# n번째 피보나치 수를 리턴
def fib(n):
    if n <= 2:
        return 1
    else:
        return fib(n-2) + fib(n-1)

# 테스트: fib(1)부터 fib(10)까지 출력
for i in range(1, 11):
    print(fib(i))
```

### 시간복잡도  : ` O(2^n)`

인풋 `n`이 `3`보다 작아지는 base case까지 반복적으로 두 개의 새로운 재귀 호출이 발생



## 2. 숫자합

### 구현

```python
# 1부터 n까지의 합을 리턴
def triangle_number(n):
    if n == 1:
        return 1
    else:
        return n + triangle_number(n-1)

# 테스트: triangle_number(1)부터 triangle_number(10)까지 출력
for i in range(1, 11):
    print(triangle_number(i))
```

### 시간 복잡도 : `O(n)`

Base case의 시간 복잡도는 인풋 크기와 연관이 없으니까 *O*(1)이다.

Recursive case에서는 `triangle_number(n - 1)`의 재귀적 호출을 제외하면 *O*(1)이다.

그런데 재귀문을 통해서 `triangle_number` 함수는 총 *n*번 호출되니까, 총 *O*(*n*)의 시간이 걸리게 된다.



## 3. 자릿수 합

### 구현

```python
# n의 각 자릿수의 합을 리턴
def sum_digits(n):
    if n < 10:
        return n 
    else:
        return sum_digits(n // 10) + (n % 10)

# 테스트
print(sum_digits(22541))
print(sum_digits(92130))
print(sum_digits(12634))
print(sum_digits(704))
print(sum_digits(3755))
```

### 시간 복잡도 : O(log10n)

인풋 *n*의 자릿수 개수를 *d*

base case 부분은 *O*(1),  `n % 10`도 *O*(1)

`sum_digits`가 재귀적으로 호출될 때마다 *n*은 약1/10로 줄어들기 때문에 매번 한 자리씩 줄어든다고 볼 수 있다.

따라서 `sum_digits`는 약 *d*번 호출된다.

`sum_digits`의 시간 복잡도는*O*(*d*)이다.

혹은 각 자릿수가 log10n + 1이라고 표기할 수 있고 그 때의 시간복잡도는 O(log10n) 이다.



## 4. 리스트 뒤집기

```python
# 파라미터 some_list를 거꾸로 뒤집는 함수
def flip(some_list):
    if len(some_list) == 0 or len(some_list) == 1:
        return some_list
    else:
        return some_list[-1:] + flip(some_list[:-1])

# 테스트
some_list = [1, 2, 3, 4, 5, 6, 7, 8, 9]
some_list = flip(some_list)
print(some_list)
```

### 리스트 슬라이싱

```python
some_list = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(some_list[-1])  # 9
print(some_list[:-1]) # [1, 2, 3, 4, 5, 6, 7, 8]
print(some_list[-1:]) # [9]
```

### 시간복잡도 : O(n^2) 

base case 는 O(1) 이고 some_list[1:] 과 some_list[:1]은 각각 시간복잡도가 O(1), O(n-1) 이다.

즉, 재귀적 부분을 제외한 시간 복잡도는 O(n)이다.

flip 함수는 매 호출마다 리스트의 길이가 1씩 줄기 때문에 총 n 번 실행된다.

재귀적으로 n번 실행되고 각 호출은 O(n) 이므로 총 시간 복잡도는 O(n^2) 이다.