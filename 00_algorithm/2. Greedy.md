# 그리디 알고리즘

- 그리디 알고리즘이란 당장 눈 앞에 보이는 최적의 선택을 하는 방식이다.
- 장점 : 간단하고 빠르다.
- 단점 : 최적의 답이 보장되지 않는다.

# 최적의 답이 보장되는 경우

1. #### **최적 부분 구조**가 있다.

2. #### **탐욕적 선택 속성**이 있다.

- 예시
  - 최대한 적은 동전을 사용해서 돈을 거슬러주기
    - 여러 가짓수로 경우의 수가 나누어지고 각각 부분문제가 존재한다.
    - 100원 5개보다 500원 1개가 낫다.



# 최소 동전으로 거슬러주기

### 내 코드

### 수정하면 좋은 부분

- 반복되는 문장을 어떻게 하면 줄일 수 있을지 고민해보자!

```python
def min_coin_count(value, coin_list):
    coin_count = 0
    coin_count += value // 500
    coin_count += (value % 500) // 100
    coin_count += ((value % 500) % 100) // 50
    coin_count += (((value % 500) % 100) % 50) // 10
    return coin_count
    
# 테스트
default_coin_list = [100, 500, 10, 50]
print(min_coin_count(1440, default_coin_list))
print(min_coin_count(1700, default_coin_list))
print(min_coin_count(23520, default_coin_list))
print(min_coin_count(32590, default_coin_list))
```

### 수정

```python
def min_coin_count(value, coin_list):
    # 누적 동전 개수 초기화
    coin_count = 0
    # coin_list 값을 큰 순서대로 정렬한다.
    for coin in sorted(default_coin_list, reverse=True):
      coin_count += value // coin
      value %= coin
    return coin_count
```



###  ✅ 파이썬 정렬을 위한 내장 메서드 list.sort()와 sorted() 내장함수

메서드는 리스트를 제자리에서 수정하는 반면, 내장함수는 새로운 정렬된 리스트를 만든다.

따라서 바로 사용할 의도이면 sorted() 함수를 쓴다.

list.sort() 를 사용할 경우 변수에 새롭게 담아야 한다. 그렇지 않으면 `None`을 반환한다.

```python
sorted([5, 2, 3, 1, 4])
# [1, 2, 3, 4, 5]
```

```python
a = [5, 2, 3, 1, 4]
a.sort()
a
# [1, 2, 3, 4, 5]
```



###  ✅ 파이썬 sorted 함수와 sort 메서드 내림차순 reverse=True

```python
sorted(timestamps, reverse=True)
# 바로 리스트로 사용이 가능하다.
```

```python
timestamps.sort(reverse=True)
# Nonetype object 반환하므로 다른 변수에 담아야 한다.
```



# 최대 곱 구하기

## 그리디 알고리즘 : 각 뭉치에서 가장 큰 값을 선택한다.

### 내 코드(힌트보고 풂)

### 수정하면 좋은 부분

- card_num과 range 를 써서 for문을 돌릴 필요 없이, 리스트를 바로 순회하여 코드를 줄일 수 있다.
- `i` 가 아닌 명확한 변수명을 지정하는 것이 좋다.

```python
def max_product(card_lists):
    """
    한 사람당 카드를 하나씩 뽑아 모두 곱했을 때 
    가능한 최대 곱을 리턴하는 함수
    """
    result = 1
    card_num = len(card_lists)
    
    for i in range(card_num):
        result *= max(card_lists[i])
    
    return result
        
# 테스트
test_cards1 = [[1, 6, 5], [4, 2, 3]]
print(max_product(test_cards1))
```

### 수정본

```python
def max_product(card_lists):
    """
    한 사람당 카드를 하나씩 뽑아 모두 곱했을 때 
    가능한 최대 곱을 리턴하는 함수
    """
    # 누적된 곱을 저장하는 변수
    product = 1
    
    # 반복문을 돌면서 카드 뭉치를 하나씩 본다.
    for card_list in card_lists:
      # product에 각 뭉치의 최댓값을 곱한다.
        result *= max(card_list)
    
    return result
        
# 테스트
test_cards1 = [[1, 6, 5], [4, 2, 3]]
print(max_product(test_cards1))
```



# 지각 벌금 적게내기

- n 번 사람이 먼저 출력하는 경우.. 각 경우로 나눠서, 각 경우의 부분문제를 풀고 서로 비교해서 최적의 답을 구할 수 있다.
- 기다리는 시간을 최소화하려면 페이지 수가 적은 사람부터 출력해야 한다. (그리디)

### 내 코드

- 페이지가 적은 사람 순으로 출력한다.

### 수정하면 좋은 부분

- 전체 인원수를 하나씩 빼는 부분을 `for` 문 안으로 합칠 수 있다.

```python
def min_fee(pages_to_print):
    """
    벌금을 가장 적게 낼 떄의 벌금을 리턴
    """
    total_fee = 0
    total_que = len(pages_to_print)
    # 뽑을 페이지 수가 가장 적은 사람부터 인쇄한다
    less_page_first = sorted(pages_to_print)
    # 첫 타자가 걸리는 시간 * 전체 인원수를 전체 시간에 추가
    # 다 뽑으면 전체 인원수 - 1
    for page in less_page_first:
        total_fee += page * total_que
        total_que -= 1
        
    return total_fee

# 테스트
print(min_fee([6, 11, 4, 1]))
print(min_fee([3, 2, 1]))
print(min_fee([3, 1, 4, 3, 2]))
print(min_fee([8, 4, 2, 3, 9, 23, 6, 8]))
```

### 수정본

```python
def min_fee(pages_to_print):
    # 인풋으로 받은 리스트를 정렬시켜 준다
   	sorted_list = sorted(pages_to_print)
    
    # 총 벌금을 담을 변수
    total_fee = 0

    # 정렬된 리스트에서 총 벌금 계산
    for i in range(len(sorted_list)):
        total_fee += sorted_list[i] * (len(sorted_list)-i)
    
    return total_fee
```



# 수강 신청 분석

- 리스트 안의 튜플은 (4, 7) 수업이 시작하는 시간과 끝나는 시간을 의미한다. 이 때, 겹치지 않고 가장 많은 수업을 들으려면?
- 최적 부분 구조 존재
- 탐욕적 선택 속성 존재 : 어떻게 골라야 하나 ... **가장 먼저 끝나는 수업을 고른다. 왜? 딱히 반례가 없다. = 남은 수업 중 가장 먼저 끝나는 수업을 선택하면 항상 최선의 결과를 만들 수 있다.**
- 따라서 그리디 알고리즘으로 최적의 솔루션 보장



###  ✅ 특정 인덱스 기준으로 리스트 정렬하기 key 매개변수로 소팅하기

특정 인덱스를 기준으로 리스트를 정렬해보자.

객체의 인덱스 중 일부를 키로 사용하여 복잡한 객체를 정렬할 수 있다.

```python
student_tuples = [
    ('john', 'A', 15),
    ('jane', 'B', 12),
    ('dave', 'B', 10),
]
# sort by age
sorted(student_tuples, key=lambda student: student[2])
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
```







