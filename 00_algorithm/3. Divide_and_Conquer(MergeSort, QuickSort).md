# Divide and Conquer

# 단계

### 1. Divide : 문제를 부분 문제로 나눈다.

### 2. Conquer : 각 부분 문제를 정복한다.

### 3. Combine : 부분 문제들의 솔루션을 합쳐 기존 문제를 해결한다.



## 1부터 n까지의 합

```python
def consecutive_sum(start, end):
    # base case
    if start == end:
        return start
    else:
        # 부분 문제를 반으로 나눠주기 위해서 문제의 정중앙을 정의 (Divide)
        mid = (start + end) // 2
        # 각 부분 문제를 재귀적으로 풀고(Conquer), 부분 문제의 답을 서로 더한다(Combine).
        return consecutive_sum(start, mid) + consecutive_sum(mid+1, end)

# 테스트
print(consecutive_sum(1, 10))
print(consecutive_sum(1, 100))
print(consecutive_sum(1, 253))
print(consecutive_sum(1, 388))
```



# 합병 정렬

## Merge 함수 작성

### 내 코드

- 여러 번 수정 끝에 맞았지만 완전히 이해하지는 못했다.
- 한 쪽이 비어있는 경우가 2 번 중복되는데 수정이 가능할까?
- `while` 문이 아닌 `for` 문으로도 가능할까?
- 한 쪽이 빈 리스트인 경우 `append`가 아닌 `extend`, `slicing` 으로 반대편 리스트를 모두 추가할 수 있도록 하였다.

### 수정하면 좋은 것

- 한 쪽이 비어있는 경우와 while 문 내의 빈 경우 중복을 없앤다.
  - `while` 문이 끝나는 조건을 길이에 도달할 때가 아닌, 길이보다 작을때로 고친다.
  - **리스트가 비어있는 경우 == 다른 한 쪽이 끝난 경우 라고 봐도 무방하다.**
- while 문의 조건을 `!=` 이 아닌 `< `로 수정할 수 있다. 좀 더 직관적이다.
- `.extend` 메서드도 좋지만 list이기 때문에 `+=` 로 더해도 된다. 좀 더 직관적이다.

```python
def merge(list1, list2):
    merged_list = []
    
    # 초기 인덱스를 설정한다.
    i,j = 0, 0
    
    # 한 쪽이 비어있는 경우
    if len(list1) == 0:
        merged_list.extend(list2[:])
    if len(list2) == 0:
        merged_list.extend(list1[:])
    
    # 양 쪽 모두 빌 때까지 반복
    while i != len(list1) and j != len(list2):
        if list1[i] < list2[j]:
            merged_list.append(list1[i])
            i += 1
            # 리스트를 다 돌았으면
            if i == len(list1):
                merged_list.extend(list2[j:])
                break
        else:
            merged_list.append(list2[j])
            j += 1
            # 리스트를 다 돌았으면
            if j == len(list2):
                merged_list.extend(list1[i:])
                break
            
    return merged_list
    
# 테스트
print(merge([1],[]))
print(merge([],[1]))
print(merge([2],[1]))
print(merge([1, 2, 3, 4],[5, 6, 7, 8]))
print(merge([5, 6, 7, 8],[1, 2, 3, 4]))
print(merge([4, 7, 8, 9],[1, 3, 6, 10]))
```

```python
[1]
[1]
[1, 2]
[1, 2, 3, 4, 5, 6, 7, 8]
[1, 2, 3, 4, 5, 6, 7, 8]
[1, 3, 4, 6, 7, 8, 9, 10]
```

### 수정 코드

```python
def merge(list1, list2):
    i,j = 0, 0
    
    # 정렬된 항목들을 담을 리스트
    merged_list = []
    
    # list1과 list2를 돌면서 merged_list에 항목 정렬
    while i < len(list1) and j < len(list2):
        if list1[i] > list2[j]:
            merged_list.append(list2[j])
            j += 1
        else:
            merged_list.append(list1[i])
            i += 1

    # (list1 끝나고) list2에 남은 항목이 있으면 정렬 리스트에 추가
    if i == len(list1):
        merged_list += list2[j:]
        
    # (list2 끝나고) list1에 남은 항목이 있으면 정렬 리스트에 추가
    if j == len(list2):
        merged_list += list1[i:]
            
    return merged_list
```

## 최종코드 - Merge 합병 정렬 구현

```python
def merge(list1, list2):
    i,j = 0, 0
    
    merged_list = []
    while i < len(list1) and j < len(list2):
        if list1[i] > list2[j]:
            merged_list.append(list2[j])
            j += 1
        else:
            merged_list.append(list1[i])
            i += 1

    # (list1 끝나고) list2에 남은 항목이 있으면 정렬 리스트에 추가
    if i == len(list1):
        merged_list += list2[j:]
    # (list2 끝나고) list1에 남은 항목이 있으면 정렬 리스트에 추가
    if j == len(list2):
        merged_list += list1[i:]
            
    return merged_list

# 합병 정렬
def merge_sort(my_list):
    # base case - 길이가 0 또는 1이라면 정렬된것이므로 리턴
    if len(my_list) < 2:
        return my_list
      
    # recursive case - divide and conquer
    # my_list를 반씩 나눈다(divide)
    left_half = my_list[:len(my_list)//2]
    right_half = my_list[len(my_list)//2:]
    
    # merge_sort 함수를 재귀적으로 호출하여 부분 문제 해결(conquer)하고,
    # merge 함수로 정렬된 두 리스트를 합쳐(combine)준다
    return merge(merge_sort(left_half), merge_sort(right_half))
  
```



