# README

---

- 접근방법은 맞았지만 구현하는 과정에서 오류가 존재하였다.
- 16진수와 2진수 8진수 이해도 부족

## 16진법

0~9 까지의 숫자를 사용하고, 9 이후부터 a,b,c,d,e,f 문자를 사용한다. 2진수 4자리를 16진수 한자리로 표현한다.

```python
A = 10
B = 11
C = 12
D = 13
E = 14
F = 15
```

## 2진수 10진수 16진수 8진수

| 2진수     | 10진수 | 16진수 | 8진수 |
| --------- | ------ | ------ | ----- |
| 0000 0000 | 0      | 0x0    | 00    |
| 0000 0001 | 1      | 0x1    | 01    |
| 0000 0010 | 2      | 0x2    | 02    |
| 0000 0011 | 3      | 0x3    | 03    |
| 0000 0100 | 4      | 0x4    | 04    |
| 0000 0101 | 5      | 0x5    | 05    |
| 0000 0110 | 6      | 0x6    | 06    |
| 0000 0111 | 7      | 0x7    | 07    |
| 0000 1000 | 8      | 0x8    | 010   |
| 0000 1001 | 9      | 0x9    | 011   |
| 0000 1010 | 10     | 0xa    | 012   |
| 0000 1011 | 11     | 0xb    | 013   |
| 0000 1100 | 12     | 0xc    | 014   |
| 0000 1101 | 13     | 0xd    | 015   |
| 0000 1110 | 14     | 0xe    | 016   |
| 0000 1111 | 15     | 0xf    | 017   |
| 0001 0000 | 16     | 0x10   | 020   |



### 오류 1

- 원인
  - 암호비트 패턴은 순서대로 나열되어 있다 하였는데 딕셔너리를 사용하였다. 

- 해결방안
  - 딕셔너리는 순서가 없는 자료형이기 때문에 리스트로 만들어야 한다.

### 오류 2

- 원인 

  - 10진수를 2진수로 변환하는 bin 내장함수를 사용할 경우 앞의 0이 생략되어 출력되기 때문에 4자리로 나오지 않는다.

    ```python
    for i in range(10):
        binary_number = bin(i)
        print(binary_number)
    
    #1  0b0   
    #2  0b1   
    #3  0b10  
    #4  0b11 
    #5  0b100 
    #6  0b101
    #7  0b110
    #8  0b111
    #9  0b1000
    #10  0b1001
    ```

- 해결방안

  - 1. 결과가 4의 배수가 아니라면 맨 앞에 문자열 '0' 을 더한다.

- 추가방법

  - format 함수를 사용하면 접두어를 지우고 출력이 가능하다.

    ```python
    for i in range(10):
        binary_number = format(i, 'b')
        print(binary_number)
    
    #1 0
    #2 1
    #3 10
    #4 11
    #5 100
    #6 101
    #7 110
    #8 111
    #9 1000
    #10 1001
    #11 1010
    ```

### 오류3

- 원인
  - 패턴을 돌면서 암호를 확인할 때, for문으로 하나하나 돌렸는데, 이렇게 되면 해당 암호를 찾아도 1씩만 옆으로 옮겨가며 확인하기 때문에 오답이 발생한다.
- 해결방안
  - 패턴매칭시 `while` 문을 활용하여, 해당 패턴이 매칭되면 그 수만큼 건너뛰고, 아니라면 한 칸 옆으로 옮겨 재검색한다.
