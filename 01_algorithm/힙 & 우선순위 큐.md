# 힙 & 우선순위 큐



# 힙

- 형태 속성 : 힙은 완전 이진 트리다.
  - 노드의 갯수가 n 일때 높이는 O(logN)이다.
- 힙 속성 : 모든 노드의 데이터는 자식 노드들의 데이터보다 크거나 같다.



# 힙 정렬 

특정 리스트를 오름차순 또는 내림차순으로 정렬



# 힙 구현하기

- 완전 이진 트리이므로 동적 배열로 구현한다.
- 한 인덱스가 하나의 노드를 나타낸다.
  - 인덱스 * 2 = 왼쪽 자식 노드
  - 인덱스 * 2 + 1 = 오른쪽 자식 노드



# heapify

- 파라미터로 한 노드를 받는다. (부모 노드)
- 부모노드가 힙 속성을 충족할 때까지 반복한다.
- 시간복잡도 : O(logN) - 높이



# heapify 함수 구현

```python
def swap(tree, index_1, index_2):
    """완전 이진 트리의 노드 index_1과 노드 index_2의 위치를 바꿔준다"""
    temp = tree[index_1]
    tree[index_1] = tree[index_2]
    tree[index_2] = temp


def heapify(tree, index, tree_size):
    """heapify 함수"""

    # 왼쪽 자식 노드의 인덱스와 오른쪽 자식 노드의 인덱스를 계산
    left_child_index = 2 * index
    right_child_index = 2 * index + 1

    largest = index  # 일단 부모 노드의 값이 가장 크다고 설정

    # 왼쪽 자식 노드의 값과 비교
    if 0 < left_child_index < tree_size and tree[largest] < tree[left_child_index]:
        largest = left_child_index

    # 오른쪽 자식 노드의 값과 비교
    if 0 < right_child_index < tree_size and tree[largest] < tree[right_child_index]:
        largest = right_child_index
    
    if largest != index: # 부모 노드의 값이 자식 노드의 값보다 작으면
        swap(tree, index, largest)  # 부모 노드와 최댓값을 가진 자식 노드의 위치를 바꿔준다
        heapify(tree, largest, tree_size)  # 자리가 바뀌어 자식 노드가 된 기존의 부모 노드를대상으로 또 heapify 함수를 호출한다
        
# 실행 코드
tree = [None, 15, 5, 12, 14, 9, 10, 6, 2, 11, 1]  # heapify하려고 하는 완전 이진 트리
heapify(tree, 2, len(tree))  # 노드 2에 heapify 호출
print(tree) 
```



# 힙으로 우선순위 큐 구현

우선순위 큐란?

- 데이터를 저장할 수 있는 추상 자료형
- 저장한 데이터가 우선순위 순서대로 나온다

### 최대 우선순위 큐

priority_queue = MaxPriorityQueue()

### 우선순위 큐에 데이터 삽입

priority_queue.add(5)

### 우선순위 큐 데이터 추출(삭제)

print(priority_queue.pop()) => 가장 큰 데이터를 리턴한다.



## 힙에 데이터를 삽입하기

1. 힙의 마지막 인덱스에 데이터를 삽입한다.
2. heapify하여 힙 속성을 맞춘다.
   1. 삽입한 데이터와 부모 노드의 데이터를 비교한다.
   2. 부모 노드의 데이터가 더 작으면 둘의 위치를 바꾼다.

### 힙 데이터 삽입 구현

```python
def reverse_heapify(tree, index):
    """삽입된 노드를 힙 속성을 지키는 위치로 이동시키는 함수"""
    parent_index = index // 2  # 삽입된 노드의 부모 노드의 인덱스 계산

    # 부모 노드가 존재하고, 부모 노드의 값이 삽입된 노드의 값보다 작을 때
    if 0 < parent_index < len(tree) and tree[index] > tree[parent_index]:
        swap(tree, index, parent_index)  # 부모 노드와 삽입된 노드의 위치 교환
        reverse_heapify(tree, parent_index)  # 삽입된 노드를 대상으로 다시 reverse_heapify 호출


class PriorityQueue:
    """힙으로 구현한 우선순위 큐"""
    def __init__(self):
        self.heap = [None]  # 파이썬 리스트로 구현한 힙


    def insert(self, data):
        """삽입 메소드"""
        self.heap.append(data)  # 힙의 마지막에 데이터 추가
        reverse_heapify(self.heap, len(self.heap)-1) # 삽입된 노드(추가된 데이터)의 위치를 재배치


    def __str__(self):
        return str(self.heap)
```



# 힙에서 우선순위가 가장 높은 데이터(root노드) 출력하기

1. root 노드와 마지막 노드를 서로 바꾼다.
2. 마지막 노드의 데이터를 변수에 저장한다.
3. 마지막 노드를 삭제한다.
4. root 노드에 heapify를 호출해서 망가진 힙 속성을 고친다.
5. 변수에 저장한 데이터를 리턴한다.(최고 우선순위 데이터)

### 힙 우선순위 데이터 추출 구현

```python
# heapify_code.py

def swap(tree, index_1, index_2):
    """완전 이진 트리의 노드 index_1과 노드 index_2의 위치를 바꿔준다"""
    temp = tree[index_1]
    tree[index_1] = tree[index_2]
    tree[index_2] = temp


def heapify(tree, index, tree_size):
    """heapify 함수"""

    # 왼쪽 자식 노드의 인덱스와 오른쪽 자식 노드의 인덱스를 계산
    left_child_index = 2 * index
    right_child_index = 2 * index + 1

    largest = index  # 일단 부모 노드의 값이 가장 크다고 설정

    # 왼쪽 자식 노드의 값과 비교
    if 0 < left_child_index < tree_size and tree[largest] < tree[left_child_index]:
        largest = left_child_index

    # 오른쪽 자식 노드의 값과 비교
    if 0 < right_child_index < tree_size and tree[largest] < tree[right_child_index]:
        largest = right_child_index
    
    if largest != index: # 부모 노드의 값이 자식 노드의 값보다 작으면
        swap(tree, index, largest)  # 부모 노드와 최댓값을 가진 자식 노드의 위치를 바꿔준다
        heapify(tree, largest, tree_size)  # 자리가 바뀌어 자식 노드가 된 기존의 부모 노드를대상으로 또 heapify 함수를 호출한다


def reverse_heapify(tree, index):
    """삽입된 노드를 힙 속성을 지키는 위치로 이동시키는 함수"""
    parent_index = index // 2  # 삽입된 노드의 부모 노드의 인덱스 계산

    # 부모 노드가 존재하고, 부모 노드의 값이 삽입된 노드의 값보다 작을 때
    if 0 < parent_index < len(tree) and tree[index] > tree[parent_index]:
        swap(tree, index, parent_index)  # 부모 노드와 삽입된 노드의 위치 교환
        reverse_heapify(tree, parent_index)  # 삽입된 노드를 대상으로 다시 reverse_heapify 호출

```

```python
# main.py
from heapify_code import *

class PriorityQueue:
    """힙으로 구현한 우선순위 큐"""
    def __init__(self):
        self.heap = [None]  # 파이썬 리스트로 구현한 힙

    def insert(self, data):
        """삽입 메소드"""
        self.heap.append(data)  # 힙의 마지막에 데이터 추가
        reverse_heapify(self.heap, len(self.heap)-1) # 삽입된 노드(추가된 데이터)의 위치를 재배치

    def extract_max(self):
        """최우선순위 데이터 추출 메소드"""
        swap(self.heap, 1, len(self.heap)-1)
        root_data = self.heap[-1]
        self.heap.pop()
        heapify(self.heap, 1, len(self.heap))
        return root_data
        

    def __str__(self):
        return str(self.heap)

# 출력 코드
priority_queue = PriorityQueue()

priority_queue.insert(6)
priority_queue.insert(9)
priority_queue.insert(1)
priority_queue.insert(3)
priority_queue.insert(10)
priority_queue.insert(11)
priority_queue.insert(13)

print(priority_queue.extract_max())
print(priority_queue.extract_max())
print(priority_queue.extract_max())
print(priority_queue.extract_max())
print(priority_queue.extract_max())
print(priority_queue.extract_max())
print(priority_queue.extract_max())
```

