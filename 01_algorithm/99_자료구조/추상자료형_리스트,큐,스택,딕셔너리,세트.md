# 기능과 구현

- 기능 : 00 연산이 "무엇"을 하는지
- 구현 : 00 연산을 "어떻게" 하는지

# 추상화

구현을 몰라도 기능만 알면 프로그래밍을 할 수 있도록 해준다.



# 추상 자료형

- 자료구조를 추상화 한 것
- 데이터를 저장/사용할 때 기능만 생각할 수 있도록 한다.



# 추상 자료형 vs. 자료구조

어떠한 특징과 연산을 가지는 존재를 특정 추상 자료형으로 부른다.

`리스트` 라는 추상 자료형은 `동적 배열`로 구현 할 수도, `링크드 리스트`로 구현할 수도 있다.

핸드폰이 `추상 자료형` 이라면 아이폰 10, 삼성 갤럭시 s10 은 `자료 구조` 이다. 자료 구조는 핸드폰을 '구현' 하고 있다.

이 둘은 서로 다른 개념이다. 기능을 중점적으로 얘기하거나 흐름을 생각하는 등, 구현에 집중하고자 하면 `추상 자료형` 을, 코드의 성능을 분석하거나 최적화시켜야 할 때는 `자료구조` 를 중심적으로 생각한다.



# 리스트(list)

> 데이터 간 순서 관계를 유지하는 추상 자료형

1. 특징

   - 데이터 간 순서 관계를 유지할 수 있다.

2. 연산

   - 접근 연산

   ```python
   trending[0]
   ```

   - 탐색 연산

   ```python
   print("1번 인덱스에 저장") in trending
   # True
   ```

   - 삽입 연산

   ```python
   trending = []
   trending.insert(0, "0번 인덱스에 저장")
   trending.insert(1, "1번 인덱스에 저장")
   trending.insert(2, "2번 인덱스에 저장")
   ```

   - 삭제 연산

   ```python
   del trending[0]
   ```

   

## 동적 배열 vs. 더블리 링크드 리스트

![image-20211008170842902](추상자료형_리스트,큐,스택,딕셔너리,세트.assets/image-20211008170842902.png)

`리스트` 라는 추상 자료형은 `동적 배열`로 구현 할 수도, `링크드 리스트`로 구현할 수도 있다.

ex. 접근을 많이 사용할 경우 => 동적 배열을 사용

파이썬 리스트는 `동적 배열`을 사용하고 있다.

# 큐(Queue)

> 데이터를 저장하는 순서대로 기억하고 가장 먼저 저장된 데이터부터 삭제할 수 있는 추상 자료형

1. 특징
   - 데이터 간 순서를 유지할 수 있다.
   - 데이터를 앞에서만 삭제하고, 뒤에서만 삽입한다.
   - FIFO : First-in-first-out
   - 가장 먼저 들어온 데이터가 가장 먼저 삭제된다. 
2. 연산
   - 맨 뒤 데이터 추가
   - 맨 앞 데이터 접근
   - 맨 앞 데이터 삭제

## deque

- Doubly-ended-queue 의 약자
- 양면 큐 자료형 : 일반 queue는 한쪽으로 들어가고 한쪽으로만 나가는데 deque는 양쪽으로 들어가고 양쪽으로 나갈 수 있다.
- 맨 앞과 맨 뒤에 데이터를 삽입하고 삭제할 수 있게 해주는 파이썬 자료형

![image-20211008172521870](추상자료형_리스트,큐,스택,딕셔너리,세트.assets/image-20211008172521870.png)

## 동적 배열 vs. 링크드 리스트

![image-20211008172641344](추상자료형_리스트,큐,스택,딕셔너리,세트.assets/image-20211008172641344.png)

파이썬 deque는 더블리 링크드 리스트로 구현되어 있다.

## 서비스센터 문의처리

### 어려웠던 점

- 클래스와 인스턴스의 이해
- 새 문의 인스턴스를 생성하고 문의 대기 큐에 추가시키는 것

### 예시답안

```python

from collections import deque

class CustomerComplaint:
    """고객 센터 문의를 나타내는 클래스"""
    def __init__(self, name, email, content):
        self.name = name
        self.email = email
        self.content = content

        
class CustomerServiceCenter:
    """고조선 호텔 서비스 센터 클래스"""
    def __init__(self):
        self.queue = deque()  # 대기 중인 문의를 저장할 큐 생성

        
    def process_complaint(self):
        """접수된 고객 센터 문의 내용 처리하는 메소드"""
        if self.queue:  # 대기 중인 문의가 있는지 확인 (if 뒤에 deque 인스턴스를 넣는다.)

            # 가장 오래된 문의 먼저 처리
            complaint = self.queue.popleft()
            # complaint의 변수에 문의 인스턴스 저장하고, complaint의 속성을 이용하여 출력
            print(f"{complaint.name}님의 {complaint.content} 문의 내용 접수되었습니다. 담당자가 배정되면 {complaint.email}로 연락드리겠습니다.")
        else:
            print("더 이상 대기 중인 문의가 없습니다.")


    def add_complaint(self, name, email, content):
        """새로운 문의를 큐에 추가 시켜주는 메소드"""
        new_complaint = CustomerComplaint(name, email, content)  # 새 문의 인스턴스 생성
        self.queue.append(new_complaint)  # 문의 대기 큐에 추가


# 고객 문의 센터 인스턴스 생성
center = CustomerServiceCenter()

# 문의 접수한다
center.add_complaint("강영훈", "younghoon@codeit.com", "음식이 너무 맛이 없어요")

# 문의를 처리한다
center.process_complaint()
center.process_complaint()

# 문의 세 개를 더 접수한다
center.add_complaint("이윤수", "yoonsoo@codeit.kr", "에어컨이 안 들어와요...")
center.add_complaint("손동욱", "dongwook@codeit.us", "결제가 제대로 안 되는 거 같군요")
center.add_complaint("김현승", "hyunseung@codeit.ca", "방을 교체해주세요")

# 문의를 처리한다
center.process_complaint()
center.process_complaint()
```



# 스택

> 데이터간 순서 관계를 유지하는 추상 자료형
>
> 가장 뒤에 데이터를 추가할 수 있고 가장 마지막 데이터를 삭제할 수 있는 추상 자료형

1. 특징
   - LIFO : Last-in-first-out
   - 가장 마지막에 들어온 데이터가 가장 먼저 삭제된다.
2. 연산
   - 맨 뒤 데이터 추가
   - 맨 뒤 데이터 접근
   - 맨 뒤 데이터 삭제

## deque

## 동적 배열 vs. 링크드 리스트

![image-20211008202609929](추상자료형_리스트,큐,스택,딕셔너리,세트.assets/image-20211008202609929.png)

스택의 경우 동적 배열로 구현하던, 더블 링크드 리스트로 구현하던 시간 복잡도 상으로는 차이가 없다. 파이썬 deque를 stack 처럼 이용할 때, deque는 더블리 링크드 리스트로 구현되어 있다. 파이썬 리스트는 동적 배열로 구현되어 있으므로, deque 대신 list를 사용해도 된다. 시간 복잡도는 같다.

![image-20211008202846328](추상자료형_리스트,큐,스택,딕셔너리,세트.assets/image-20211008202846328.png)

## 괄호 짝 확인하기

`parentheses_checker`는 `string` 안에 있는 모든 짝이 없는 괄호를 찾아내서 이 괄호들이 문자열 어디 위치에 있는지를 출력해줍니다. 만약 문자열 안에 모든 괄호가 짝이 있으면 함수는 아무 내용도 출력하지 않습니다.

### 어려웠던 점

- 괄호의 '위치' 를 출력하려면 어떻게 해야하나?
- pop() 메서드로 마지막 데이터만 꺼낼 수 있는데, 남는 괄호가 여러개면 어떻게 하나?
- 경우의 수를 어떻게 분기처리해야 하나?

### 해결포인트

- 여는 괄호의 '위치' 를 스택에 넣어준다.
- 닫는 괄호를 만나면
  - 스택에 여는 괄호 있는 경우 => 스택에서 삭제
  - 스택에 여는 괄호 없는 경우 => 닫는괄호 위치 출력
- 다 돌았는데 여는 괄호가 남아있다면
  - 여는 괄호의 위치를 출력, 이 때 stack 이 빌 때 까지 출력

### 예시답안

```python
from collections import deque

def parentheses_checker(string):
    """주어진 문자열 인풋의 모든 괄호가 짝이 있는지 확인해주는 메소드"""

    stack = deque()  # 사용할 스택 정의

    print(f"테스트하는 문자열: {string}") 

    # 문자열의 각 문자를 돌면서
    for i in range(len(string)):
        # 열리는 괄호가 있는 위치를 스택에 저장한다
        if string[i] == "(":
            stack.append(i)
        # 닫히는 괄호가 있으면
        elif string[i] == ")":
            # 스택에 열린 괄호 위치 데이터가 있으면 삭제하고
            if stack:
                stack.pop()
            # 아니면 현재 위치에 있는 닫는 괄호에 맞는 열리는 괄호가 없다고 출력한
            else:
                print(f"문자열 {i} 번째 위치에 있는 닫는 괄호에 맞는 열리는 괄호가 없습니다")

    # 스택에 열린 괄호 위치 데이터가 남아 있으면 해당 열린 괄호는 짝이 맞는 닫힌 괄호가 없다는 뜻이다
    while stack:
        print(f"문자열 {stack.pop()} 번째 위치에 있는 괄호가 닫히지 않았습니다")
```



# 딕셔너리

> 키-밸류 쌍을 저장하는 추상 자료형

1. 특징
   - 저장하는 데이터 간의 순서를 약속하지는 않는다.
2. 연산
   - key-value 데이터 쌍 삽입
   - key를 이용한 데이터 탐색
   - key를 이용한 데이터 삭제

![image-20211009000110944](/Users/euijinpang/TIL/00_algorithm/자료구조/추상자료형_리스트,큐,스택,딕셔너리,세트.assets/image-20211009000110944-3705311.png)

![image-20211009000140187](/Users/euijinpang/TIL/00_algorithm/자료구조/추상자료형_리스트,큐,스택,딕셔너리,세트.assets/image-20211009000140187-3705303.png)

파이썬 딕셔너리는 해시 테이블을 사용한다.

# 세트(set)

>순서에 상관 없이 데이터를 저장할 수 있는 추상자료

1. 특징
   - 데이터 간 순서 관계를 약속하지 않음
2. 연산
   - 삽입 : 데이터를 저장 할 수 있다. (중복x)
   - 탐색 : 데이터가 저장됐는지 확인할 수 있다.
   - 저장 : 저장한 데이터를 지울 수 있다.

![image-20211009000705745](/Users/euijinpang/TIL/00_algorithm/자료구조/추상자료형_리스트,큐,스택,딕셔너리,세트.assets/image-20211009000705745.png)