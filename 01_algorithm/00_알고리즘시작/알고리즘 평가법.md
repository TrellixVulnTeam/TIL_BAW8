# 시간 : 빠르게

## 시간 복잡도 (Time Complexity)

데이터가 많아질수록 걸리는 시간이 얼마나 급격하게 증가하는가

![image-20211002164210176](알고리즘 평가법.assets/image-20211002164210176.png)



## 거듭제곱과 로그

![image-20211002164443639](알고리즘 평가법.assets/image-20211002164443639.png)

![image-20211002164512365](알고리즘 평가법.assets/image-20211002164512365.png)



## 1부터 n 까지의 합

![image-20211002164644643](알고리즘 평가법.assets/image-20211002164644643.png)



## 점근 표기법(Big-O Notation)

n이 "엄청 큰" 경우를 가정한다.

절대적인 시간이 아닌 성장성을 보는 것이다.

![image-20211002165117026](알고리즘 평가법.assets/image-20211002165117026.png)

![image-20211002165203592](알고리즘 평가법.assets/image-20211002165203592.png)

## 탐색 알고리즘 평가하기

- 최고의 경우 : 처음에 찾는다.
- 최악의 경우 : 찾는 수가 없다.

![image-20211002165424693](알고리즘 평가법.assets/image-20211002165424693.png)

# 코드의 모든 줄은 *O*(1)인가요?

아닙니다!

인풋 크기와 상관 없이 실행되는 코드만 O(1)*O*(1)입니다. 그렇지 않은 코드는 시간 복잡도를 따져봐야 합니다.

예를 들어서 `sorted` 함수나 `sort` 메소드를 사용하면 내부적으로 O(n\lg{n})*O*(*n*lg*n*)의 정렬이 이루어집니다.

만약 리스트에서 `in` 키워드를 통해 값의 존재 여부를 확인하면 내부적으로 O(n)*O*(*n*)의 선형 탐색이 이루어집니다.

그 외에도 알아야 할 것들이 많은데, 이번 수업에서는 아래의 몇 가지만 알아두세요.

이 모든 것을 정말 제대로 이해하고 싶다면, 이후에 자료구조 수업을 수강하시면 됩니다!

# List Operations

리스트의 길이를 n*n*이라고 합시다.

| Operation           | Code                               | Average Case            |
| :------------------ | :--------------------------------- | :---------------------- |
| 인덱싱              | `my_list[index]`                   | O(1)*O*(1)              |
| 정렬                | `my_list.sort()` `sorted(my_list)` | O(n\lg{n})*O*(*n*lg*n*) |
| 뒤집기              | `my_list.reverse()`                | O(n)*O*(*n*)            |
| 탐색                | `element in my_list`               | O(n)*O*(*n*)            |
| 끝에 요소 추가      | `my_list.append(element)`          | O(1)*O*(1)              |
| 중간에 요소 추가    | `my_list.insert(index, element)`   | O(n)*O*(*n*)            |
| 삭제                | `del my_list[index]`               | O(n)*O*(*n*)            |
| 최솟값, 최댓값 찾기 | `min(my_list)` `max(my_list)`      | O(n)*O*(*n*)            |
| 길이 구하기         | `len(my_list)`                     | O(1)*O*(1)              |
| 슬라이싱            | `my_list[a:b]`                     | O(b - a)*O*(*b*−*a*)    |

# Dictionary Operations

| Operation            | Code                   | Average Case |
| -------------------- | ---------------------- | ------------ |
| 값 찾기              | `my_dict[key]`         | O(1)*O*(1)   |
| 값 넣어주기/덮어쓰기 | `my_dict[key] = value` | O(1)*O*(1)   |
| 값 삭제              | `del my_list[key]`     | O(1)*O*(1)   |





---



# 시간복잡도 총정리

# *O*(1)

O(1)*O*(1)은 인풋의 크기가 소요 시간에 영향이 없다는 뜻입니다.

```python
# O(1) 함수
def print_first(my_list):
    print(my_list[0]) 

print_first([2, 3])
print_first([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53])
```

`print_first` 함수를 처음 호출할 때는 요소가 2개밖에 없는 리스트를 넘겨줬는데, 두 번째 호출할 때는 요소가 16개 있는 리스트를 넘겨줬습니다. 그런데 사실 두 경우 걸리는 시간은 거의 똑같습니다. 어차피 맨 앞에 있는 요소를 받아오는 것 뿐이니까, 리스트의 길이는 상관이 없는 거죠. 길이가 10만씩이나 되는 리스트를 넘겨줘도 똑같을 것입니다.

나름의 팁을 드리자면, 반복문이 없으면 대체로 O(1)*O*(1)입니다.

# *O*(*n*)

## Case 1

```python
# O(n) 함수
def print_each(my_list):
    for i in range(len(my_list)):
        print(my_list[i])
```

반복문이 있고, 반복되는 횟수가 인풋의 크기와 비례하면 일반적으로 O(n)*O*(*n*)입니다.

## Case 2

```python
# O(n) 함수
def print_half(my_list):
    for i in range(len(my_list) // 2):
        print(my_list[i])
```

*n*번 반복하는 게 아니라 *n*/2번 반복한다면 시간 복잡도가 어떻게 될까요? O(\frac{1}{2}n)이지만, \frac{1}{2}21을 버려서 결론적으로는 O*(*n*)이라고 할 수 있습니다.

## Case 3

```python
# O(n) 함수
def print_three_times(my_list):
    for i in range(len(my_list)):
        print(my_list[i])

    for i in range(len(my_list)):
        print(my_list[i])

    for i in range(len(my_list)):
        print(my_list[i])
```

위 코드의 경우 O*(3*n*)인데, 결국에는 3을 버려서 이것 또한 *O*(*n*)이라고 할 수 있겠죠?

# O(n^2)

그런데 반복문이 연속해서 나오는 게 아니라, 반복문 안에 반복문이 있는 경우가 있습니다.

```python
# O(n^2) 함수
def print_pairs(my_list):
    for i in range(len(my_list)):
        for j in range(len(my_list)):
            print(my_list[i], my_list[j])
```

지금처럼 두 반복문 다 인풋의 크기에 비례하는 경우, O(n^2)이라고 할 수 있습니다.

# O(n^3)

```python
# O(n^3) 함수
def print_triplets(my_list):
    for i in range(len(my_list)):
        for j in range(len(my_list)):
            for k in range(len(my_list)):
                print(my_list[i], my_list[j], my_list[k])
```

동일한 원리로, 인풋의 크기에 비례하는 반복문이 세 번 중첩되면 O(n^3)*이 되겠죠?

# *O*(lg*n*)

## Case 1

```python
# O(lg n) 함수
# 2의 거듭제곱을 출력하는 함수
# (이번에는 인풋이 리스트가 아니라 그냥 정수입니다)
def print_powers_of_two(n):
    i = 1
    while i < n:
        print(i)
        i = i * 2
```

이번에는 반복문이 조금 특이합니다. `i`가 두 배씩 증가하네요.

인풋 `n`이 `128`이면 반복문이 총 몇 번 실행될까요? `i`가 `1`일 때부터 `2`, `4`, `8`, `16`, `32`, `64`까지 총 7번 실행됩니다. lg128도 7인 건 우연이 아닙니다!

`print_powers_of_two` 함수는 *O*(lg*n*)입니다.

## Case 2

```python
# O(lg n) 함수
# 2의 거듭제곱을 출력하는 함수
# (이번에는 인풋이 리스트가 아니라 그냥 정수입니다)
def print_powers_of_two(n):
    i = n
    while i > 1:
        print(i)
        i = i / 2
```

`i`를 `1`부터 시작해서 두 배씩 곱하는 게 아니라, `n`부터 시작해서 반씩 나눠봅시다. 이 경우에도 `i`가 `128`일 때부터 `64`, `32`, `16`, `8`, `4`, `2`까지 반복문이 7번 실행됩니다.

두 경우 모두 *O*(lg*n*)입니다.

# *O*(*n*lg*n*)

O(n^2))은 O(n)과 O(n)이 중첩된 거죠? 같은 논리로, O*(*n*lg*n*)은 *O*(*n*)과 *O*(lg*n*)이 겹쳐진 것입니다.

## Case 1

```python
def print_powers_of_two_repeatedly(n):
    for i in range(n): # 반복횟수: n에 비례
        j = 1
        while j < n: # 반복횟수: lg n에 비례
            print(i, j)
            j = j * 2
```

위 코드에서 for문의 반복횟수는 *n*에 비례하는데, while문의 반복횟수는 lg*n*에 비례합니다. while문이 for문 안에 중첩되어 있기 때문에 위 코드의 시간 복잡도는 *O*(*n*lg*n*)이라고 할 수 있습니다.

## Case 2

```python
def print_powers_of_two_repeatedly(n):
    i = 1
    while i < n: # 반복횟수: lg n에 비례
        for j in range(n): # 반복횟수: n에 비례
            print(i, j)
        i = i * 2
```

Case 1의 코드를 살짝 바꿔서 이제 for문이 while문 안에 중첩되어 있습니다. 이 경우에도 시간 복잡도는 *O*(*n*lg*n*)입니다.





---



# 공간 : 메모리를 적게

인풋 크기에 비례해서 알고리즘이 사용하는 메모리 공간

# *O*(1)

```python
def product(a, b, c):
    result = a * b * c
    return result
```

파라미터 `a`, `b`, `c`가 차지하는 공간을 제외하면 추가적으로 변수 `result`가 공간을 차지합니다. `result`가 차지하는 메모리 공간은 인풋과 무관하기 때문에 함수 `product`의 공간 복잡도는 *O*(1)입니다.

# *O*(*n*)

```python
def get_every_other(my_list):
    every_other = my_list[::2]
    return every_other
```

인풋 `my_list`의 길이를 *n*이라고 합시다.

파라미터 `my_list`가  차지하는 공간을 제외하면 추가적으로 변수 `every_other`가 공간을 차지합니다. `every_other`가 차지하는 공간은 어떻게 표현할 수 있을까요?

리스트 `every_other`에는 `my_list`의 짝수 인덱스의 값들이 복사돼서 들어갑니다. 약 2*n*개의 값이 들어간다는 거죠. O*(2*n*)은  *O*(*n*)으로 나타낼 수 있기 때문에, `get_every_other` 함수의 공간 복잡도는 *O*(*n*)입니다.

# O(n^2)

```python
def largest_product(my_list):
    products = []
    for a in my_list:
        for b in my_list:
            products.append(a * b)
    
    return max(products)
```

인풋 `my_list`의 길이를 *n*이라고 합시다.

파라미터 `my_list`가 차지하는 공간을 제외하면 추가적으로 변수 `products`, `a`, `b`가 공간을 차지합니다. 우선 `a`와 `b`는 그냥 정수 값을 담기 때문에 *O*(1)이겠죠? 그렇다면 `products`가 차지하는 공간은 어떻게 표현할 수 있을까요?

리스트 `products`에는 `my_list`에서 가능한 모든 조합의 곱이 들어갑니다. 그렇다면 총 *n^2* 개의 값이 들어가겠죠? 따라서 `largest_product`의 공간 복잡도는 O(n^2)입니다.



---



# 유용한 파이썬 기능 정리

# type

```python
print(type([7, 5, 2, 3, 6])) # => <class 'list'>
print(type(5))               # => <class 'int'>
print(type(3.14))            # => <class 'float'>
print(type(True))            # => <class 'bool'>
print(type("True"))          # => <class 'str'>
```

`type` 함수를 사용하면 파라미터의 데이터 타입이 리턴됩니다. 시간 복잡도는 *O*(1)입니다.

# max, min

```python
print(max(2, 5))             # => 5
print(max(2, 7, 5))          # => 7
print(min(2, 5))             # => 2
print(min(2, 7, 5, 11, 6))   # => 2
```

`max` 함수를 사용하면 파라미터 중 가장 큰 값이 리턴되고, `min` 함수를 사용하면 파라미터 중 가장 작은 값이 리턴됩니다. 두 함수 모두 파라미터 개수가 유동적이기 때문에 원하는 만큼 넘겨 줄 수 있습니다.

파라미터의 개수를 n*n*이라고 하면, `max` 함수와 `min` 함수의 시간 복잡도는 *O*(*n*)입니다.

# str

```python
my_str = str(257138)
print(my_str)                # => 257138
print(type(my_str))          # => <class 'str'>
```

`str` 함수를 사용하면 숫자를 문자열로 바꿀 수 있습니다.

파라미터를 *n*이라고 하고 *n*의 자릿수를 *d*라고 합시다. 그러면 `str` 함수의 시간 복잡도는 *O*(log*n*)으로 나타낼 수도 있고 O*(*d*)로 나타낼 수도 있습니다.

257138은 자릿수가 몇 개인지 따져보면 *O*(log10*n*)라고 할 수 있다. 그러니까 *O*(log*n*)은 정수 *n*의 자릿수를 표현한다. 자릿수 d = *d*=*O*(*l**o**g*10*n*)이기 때문에 *d*가 아닌 *n*을 써서 시간복잡도를 나타낸다.

# append, insert, del, index, reverse

```python
my_list = [7, 5, 2, 3, 6]

my_list.append(9)            # 끝에 9 추가
print(my_list)               # => [7, 5, 2, 3, 6, 9]

my_list.insert(2, 11)        # 2번 인덱스에 11 추가
print(my_list)               # => [7, 5, 11, 2, 3, 6, 9]

del my_list[2]               # 2번 인덱스 값 삭제
print(my_list)               # => [7, 5, 2, 3, 6, 9]

my_index = my_list.index(9)  # 리스트에서 9의 인덱스
print(my_index)              # => 5

my_list.reverse()            # 리스트 뒤집기
print(my_list)               # => [9, 6, 3, 2, 5, 7]
```

`append` 메소드를 사용하면 리스트 끝에 새로운 값이 추가됩니다. 시간 복잡도는 *O*(1)입니다.

`insert`, `del`, `index`, `reverse`는 모두 *O*(*n*)입니다.

# sort, sorted

```python
my_list = [7, 5, 2, 3, 6]

print(sorted(my_list))       # => [2, 3, 5, 6, 7]
print(my_list)               # => [7, 5, 2, 3, 6]

my_list.sort()
print(my_list)               # => [2, 3, 5, 6, 7]
```

`sort` 메소드와 `sorted` 함수는 리스트를 정렬시켜 줍니다. `sorted` 함수를 사용하면 정렬된 새로운 리스트가 리턴되고, `sort` 메소드는 그 리스트 자체를 정렬시켜 준다는 차이점이 있습니다.

두 메소드의 시간 복잡도는 모두 *O*(*n*lg*n*)입니다.

# slicing

```python
my_list = [7, 5, 2, 3, 6]

print(my_list[1:4])          # => [5, 2, 3]
print(my_list[:4])           # => [7, 5, 2, 3]
print(my_list[1:])           # => [5, 2, 3, 6]
print(my_list[:])            # => [7, 5, 2, 3, 6]
print(my_list[::2])          # => [7, 2, 6]
```

리스트 슬라이싱을 하면 리스트의 일부를 받아 올 수 있습니다. 리스트 슬라이싱의 시간 복잡도는 슬라이싱의 범위 길이에 비례합니다. `my_list[a:b]`를 하면 시간 복잡도는 O(b - a)*O*(*b*−*a*)입니다.

# len

```python
my_list = [7, 5, 2, 3, 6]
my_dict = {'a': 2, 'b': 3, 'c': 5, 'd': 7}
my_string = 'hello world'

print(len(my_list))          # => 5
print(len(my_dict))          # => 4
print(len(my_string))        # => 11
```

`len` 함수를 사용하면 리스트, 사전, 문자열 등의 길이가 리턴됩니다. 시간 복잡도는 *O*(1)입니다.

리스트/사전/집합 등 파이썬 자료구조는 몇개의 요소가 들어있는지를(internal count) 내부적으로 저장합니다 (`.append()`같은 함수를 호출하면 internal count도 1이 증가합니다). 따라서 `len(자료구조)`을 실행하는 경우 `자료구조`의 internal count를 바로 return하면 되기 때문에 O(1)입니다.
