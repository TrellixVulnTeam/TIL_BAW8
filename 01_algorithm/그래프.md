# 인접행렬 vs. 인접리스트

V : 그래프 안에 있는 모든 노드들의 집합 // 모든 노드의 수 

E : 그래프 안에 있는 모든 엣지들의 집합 // 모든 엣지의 수



## 인접행렬

1. 차지하는 공간 :  노드 수 x 노드 수 => **O(V ^ 2)**
2. 두 노드 연결여부 확인 소요시간 :  인덱스 사용 => **O(1)**



## 인접 리스트 

1. 차지하는 공간:

모든 노드는 하나의 리스트를 가지므로 노드 저장시 O(V), 엣지 저장시 무방향시 2E, 방향시 E, 즉 O(E)

따라서 결과적으로 **O(V + E)** 만큼의 공간 사용단, 최악의 경우 (모든 노드가 서로 다른 모든 노드에 연결시) **V ^ 2** 에 비례.

2. 두 노드 연결여부 확인 소요시간 : 선형 탐색이므로 최악의 경우 **O(V)**



## 한 노드에 연결된 모든 노드들을 알아내는 데 걸리는 시간

- 인접 행렬의 경우 : 한 노드 확인할 때 마다, 리스트 안에 있는 데이터를 다 돌아야 하므로 "V"
- 인접 리스트의 경우 : 자신과 인접한 노드만 가지고 있으므로 "V" 보다 적은 경우가 대부분이다.
- 결론 : 이 경우 인접 리스트가 인접 행렬보다 효율적이다.

# 그래프 노드

```python
class StationNode:
    """간단한 지하철 역 노드 클래스"""
    def __init__(self, station_name):
        self.station_name = station_name
        
def create_station_nodes(input_file):
    """input_file에서 데이터를 읽어 와서 지하철 그래프 노드들을 리턴하는 함수"""
    stations = {}  # 지하철 역 노드들을 담을 딕셔너리

    # 파라미터로 받은 input_file 파일을 연다
    with open(input_file) as stations_raw_file:
      	# 파일을 한 줄씩 받아온다
        for line in stations_raw_file:  
            # 앞 뒤 띄어쓰기를 없애고 "-"를 기준점으로 데이터를 나눈다
            subway_line = line.strip().split("-")
            
						# 앞 뒤 띄어쓰기 없애기
            for name in subway_line:
                station_name = name.strip()  
                
                # 지하철 역 이름이 이미 저장되어 있지 않은 경우에만 저장
                if station_name not in stations:
                    # 새로운 인스턴스 생성
                    current_station = StationNode(station_name) 
                    # 딕셔너리에 역 이름은 key로, 노드 인스턴스는 value로 저장
                    stations[station_name] = current_station 

    return stations

stations = create_station_nodes("./stations.txt")  # stations.txt 파일로 그래프 노드들을 만든다

# stations에 저장한 역들 이름 출력 (채점을 위해 역 이름 순서대로 출력)
for station in sorted(stations.keys()):
    print(stations[station].station_name)
```



# 인접리스트

```python
def create_subway_graph(input_file):
    """input_file에서 데이터를 읽어 와서 지하철 그래프를 리턴하는 함수"""
    stations = {}  # 지하철 역 노드들을 담을 딕셔너리

    # 파라미터로 받은 input_file 파일을 연다
    with open(input_file) as stations_raw_file:
        for line in stations_raw_file:  # 파일을 한 줄씩 받아온다
            previous_station = None  # 엣지를 저장하기 위한 도우미 변수. 현재 보고 있는 역 전 역을 저장한다
            subway_line = line.strip().split("-")  # 앞 뒤 띄어쓰기를 없애고 "-"를 기준점으로 데이터를 나눈다

            for name in subway_line:
                station_name = name.strip()  # 앞 뒤 띄어쓰기 없애기

                # 지하철 역 이름이 이미 저장한 key 인지 확인
                if station_name not in stations:
                    current_station = StationNode(station_name)  # 새로운 인스턴스를 생성하고
                    stations[station_name] = current_station  # dictionary에 역 이름은 key로, 역 인스턴스를 value로 저장한다

                else:
                    current_station = stations[station_name]  # 이미 저장한 역이면 stations에서 역 인스턴스를 갖고 온다

                if previous_station is not None:
                    current_station.add_connection(previous_station)  # 현재 역과 전 역의 엣지를 연결한다

                previous_station = current_station  # 현재 역을 전 역으로 저장

    return stations
```



# BFS 구현

```python
from collections import deque
from subway_graph import create_station_graph

def bfs(graph, start_node):
    """시작 노드에서 bfs를 실행하는 함수"""
    queue = deque()  # 빈 큐 생성

    # 일단 모든 노드를 방문하지 않은 노드로 표시
    for station_node in graph.values():
        station_node.visited = False

    # 시작 노드 방문체크, 큐에 넣는다.
    start_node.visited = True
    queue.append(start_node)
    
    # 큐가 빌 때 까지
    while queue:
        # 큐 제일 앞 노드를 꺼내서
        current_station = queue.popleft()
        # 인접한 노드들(연결)을 돌면서 (인접리스트!!)
        # 방문하지 않았으면 방문체크 하고 큐에 넣는다. (메서드 사용!!)
        for neighbor in current_station.adjacent_stations:
            if not neighbor.visited:
                neighbor.visited = True
                queue.append(neighbor)
 
    
stations = create_station_graph("./new_stations.txt")  # stations.txt 파일로 그래프를 만든다

gangnam_station = stations["강남"]

# 강남역과 경로를 통해 연결된 모든 노드를 탐색
bfs(stations, gangnam_station)

# 강남역과 서울 지하철 역들이 연결됐는지 확인
print(stations["강동구청"].visited)
print(stations["평촌"].visited)
print(stations["송도"].visited)
print(stations["개화산"].visited)

# 강남역과 대전 지하철 역들이 연결됐는지 확인
print(stations["반석"].visited)
print(stations["지족"].visited)
print(stations["노은"].visited)
print(stations["(대전)신흥"].visited)
```

# DFS

```python
from collections import deque
from subway_graph import *

def dfs(graph, start_node):
    """dfs 함수"""
    stack = deque()  # 빈 스택 생성

    # 모든 노드를 처음 보는 노드로 초기화
    for station_node in graph.values():
        station_node.visited = 0

    # 시작점을 스택에 넣는다. (방문처리 하지않는다! BFS와 차이점)
    start_node.visited = 1
    stack.append(start_node)

    
    # 스택이 남아 있는 동안
    while stack:
        # 스택에서 가장 마지막 노드를 빼고
        current_station = stack.pop()
        # 방문처리한다. (꺼낼 때 방문처리 하기 때문에 BFS와의 차이점!!)
        current_station.visited = 2
        # 이 노드와 연결되어있는 인접노드를 돌면서
        for neighbor in current_station.adjacent_stations:
            # 아직 방문하지 않은 노드이면
            if neighbor.visited == 0:
                # 스택에 넣는다. 
                stack.append(neighbor)
                neighbor.visited = 2


stations = create_station_graph("./new_stations.txt")  # stations.txt 파일로 그래프를 만든다

gangnam_station = stations["강남"]

# 강남역과 경로를 통해 연결된 모든 노드를 탐색
dfs(stations, gangnam_station)

# 강남역과 서울 지하철 역들 연결됐는지 확인
print(stations["강동구청"].visited)
print(stations["평촌"].visited)
print(stations["송도"].visited)
print(stations["개화산"].visited)

# 강남역과 대전 지하철 역들 연결됐는지 확인
print(stations["반석"].visited)
print(stations["지족"].visited)
print(stations["노은"].visited)
print(stations["(대전)신흥"].visited)

```

# 최단경로 - BFS

```python
from collections import deque
from subway_graph import *

# 코드를 추가하세요
def bfs(graph, start_node):
    """최단 경로용 bfs 함수"""
    queue = deque()  # 빈 큐 생성

    # 모든 노드를 방문하지 않은 노드로 표시, 모든 predecessor는 None으로 초기화
    for station_node in graph.values():
        station_node.visited = False
        station_node.predecessor = None

    # 시작점 노드를 방문 표시한 후 큐에 넣어준다
    start_node.visited = True
    queue.append(start_node)
    
    while queue:  # 큐에 노드가 있을 때까지
        current_station = queue.popleft()  # 큐의 가장 앞 데이터를 갖고 온다
        for neighbor in current_station.adjacent_stations:  # 인접한 노드를 돌면서
            if not neighbor.visited:  # 방문하지 않은 노드면
                neighbor.visited = True  # 방문 표시를 하고
                neighbor.predecessor = current_station # 이 노드가 어디서 왔는지 표시 
                queue.append(neighbor)  # 큐에 넣는다

def back_track(destination_node):
    """최단 경로를 찾기 위한 back tracking 함수"""
    
    res_str = ""  # 리턴할 결과 문자열
    temp = destination_node # 도착 노드에서 시작 노드까지 찾아가는데 필요한 변수 
    
    # 시작 노드까지 갈 때까지
    while temp is not None:
        res_str = f"{temp.station_name} {res_str}"  # 결과 문자열에 역 이름을 더하고
        temp = temp.predecessor  n# temp를 다음 노드로 바꿔준다
        
    return res_str
        
        
stations = create_station_graph("./new_stations.txt")  # stations.txt 파일로 그래프를 만든다
# print(bfs(stations, stations["을지로3가"]) )
bfs(stations, stations["을지로3가"])  # 지하철 그래프에서 을지로3가역을 시작 노드로 bfs 실행
print(back_track(stations["강동구청"]))  # 을지로3가에서 강동구청역까지 최단 경로 출력
```

